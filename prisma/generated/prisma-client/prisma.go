// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) DomainUser(params DomainUserWhereUniqueInput) *DomainUserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"DomainUserWhereUniqueInput!", "DomainUser"},
		"domainUser",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

type DomainUsersParams struct {
	Where   *DomainUserWhereInput   `json:"where,omitempty"`
	OrderBy *DomainUserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) DomainUsers(params *DomainUsersParams) *DomainUserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DomainUserWhereInput", "DomainUserOrderByInput", "DomainUser"},
		"domainUsers",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExecArray{ret}
}

type DomainUsersConnectionParams struct {
	Where   *DomainUserWhereInput   `json:"where,omitempty"`
	OrderBy *DomainUserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) DomainUsersConnection(params *DomainUsersConnectionParams) DomainUserConnectionExec {
	panic("not implemented")
}

func (client *Client) Endpoint(params EndpointWhereUniqueInput) *EndpointExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EndpointWhereUniqueInput!", "Endpoint"},
		"endpoint",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

type EndpointsParams struct {
	Where   *EndpointWhereInput   `json:"where,omitempty"`
	OrderBy *EndpointOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Endpoints(params *EndpointsParams) *EndpointExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EndpointWhereInput", "EndpointOrderByInput", "Endpoint"},
		"endpoints",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExecArray{ret}
}

type EndpointsConnectionParams struct {
	Where   *EndpointWhereInput   `json:"where,omitempty"`
	OrderBy *EndpointOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) EndpointsConnection(params *EndpointsConnectionParams) EndpointConnectionExec {
	panic("not implemented")
}

func (client *Client) FileHistory(params FileHistoryWhereUniqueInput) *FileHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FileHistoryWhereUniqueInput!", "FileHistory"},
		"fileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

type FileHistoriesParams struct {
	Where   *FileHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *FileHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) FileHistories(params *FileHistoriesParams) *FileHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileHistoryWhereInput", "FileHistoryOrderByInput", "FileHistory"},
		"fileHistories",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExecArray{ret}
}

type FileHistoriesConnectionParams struct {
	Where   *FileHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *FileHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) FileHistoriesConnection(params *FileHistoriesConnectionParams) FileHistoryConnectionExec {
	panic("not implemented")
}

func (client *Client) Rule(params RuleWhereUniqueInput) *RuleExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RuleWhereUniqueInput!", "Rule"},
		"rule",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

type RulesParams struct {
	Where   *RuleWhereInput   `json:"where,omitempty"`
	OrderBy *RuleOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Rules(params *RulesParams) *RuleExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RuleWhereInput", "RuleOrderByInput", "Rule"},
		"rules",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExecArray{ret}
}

type RulesConnectionParams struct {
	Where   *RuleWhereInput   `json:"where,omitempty"`
	OrderBy *RuleOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) RulesConnection(params *RulesConnectionParams) RuleConnectionExec {
	panic("not implemented")
}

func (client *Client) RuleResult(params RuleResultWhereUniqueInput) *RuleResultExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RuleResultWhereUniqueInput!", "RuleResult"},
		"ruleResult",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

type RuleResultsParams struct {
	Where   *RuleResultWhereInput   `json:"where,omitempty"`
	OrderBy *RuleResultOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) RuleResults(params *RuleResultsParams) *RuleResultExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RuleResultWhereInput", "RuleResultOrderByInput", "RuleResult"},
		"ruleResults",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExecArray{ret}
}

type RuleResultsConnectionParams struct {
	Where   *RuleResultWhereInput   `json:"where,omitempty"`
	OrderBy *RuleResultOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) RuleResultsConnection(params *RuleResultsConnectionParams) RuleResultConnectionExec {
	panic("not implemented")
}

func (client *Client) Scan(params ScanWhereUniqueInput) *ScanExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ScanWhereUniqueInput!", "Scan"},
		"scan",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

type ScansParams struct {
	Where   *ScanWhereInput   `json:"where,omitempty"`
	OrderBy *ScanOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Scans(params *ScansParams) *ScanExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ScanWhereInput", "ScanOrderByInput", "Scan"},
		"scans",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExecArray{ret}
}

type ScansConnectionParams struct {
	Where   *ScanWhereInput   `json:"where,omitempty"`
	OrderBy *ScanOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) ScansConnection(params *ScansConnectionParams) ScanConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateDomainUser(params DomainUserCreateInput) *DomainUserExec {
	ret := client.Client.Create(
		params,
		[2]string{"DomainUserCreateInput!", "DomainUser"},
		"createDomainUser",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

type DomainUserUpdateParams struct {
	Data  DomainUserUpdateInput      `json:"data"`
	Where DomainUserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateDomainUser(params DomainUserUpdateParams) *DomainUserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"DomainUserUpdateInput!", "DomainUserWhereUniqueInput!", "DomainUser"},
		"updateDomainUser",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

type DomainUserUpdateManyParams struct {
	Data  DomainUserUpdateManyMutationInput `json:"data"`
	Where *DomainUserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyDomainUsers(params DomainUserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"DomainUserUpdateManyMutationInput!", "DomainUserWhereInput"},
		"updateManyDomainUsers")
	return &BatchPayloadExec{exec}
}

type DomainUserUpsertParams struct {
	Where  DomainUserWhereUniqueInput `json:"where"`
	Create DomainUserCreateInput      `json:"create"`
	Update DomainUserUpdateInput      `json:"update"`
}

func (client *Client) UpsertDomainUser(params DomainUserUpsertParams) *DomainUserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"DomainUserWhereUniqueInput!", "DomainUserCreateInput!", "DomainUserUpdateInput!", "DomainUser"},
		"upsertDomainUser",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

func (client *Client) DeleteDomainUser(params DomainUserWhereUniqueInput) *DomainUserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"DomainUserWhereUniqueInput!", "DomainUser"},
		"deleteDomainUser",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

func (client *Client) DeleteManyDomainUsers(params *DomainUserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "DomainUserWhereInput", "deleteManyDomainUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEndpoint(params EndpointCreateInput) *EndpointExec {
	ret := client.Client.Create(
		params,
		[2]string{"EndpointCreateInput!", "Endpoint"},
		"createEndpoint",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

type EndpointUpdateParams struct {
	Data  EndpointUpdateInput      `json:"data"`
	Where EndpointWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEndpoint(params EndpointUpdateParams) *EndpointExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EndpointUpdateInput!", "EndpointWhereUniqueInput!", "Endpoint"},
		"updateEndpoint",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

type EndpointUpdateManyParams struct {
	Data  EndpointUpdateManyMutationInput `json:"data"`
	Where *EndpointWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEndpoints(params EndpointUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EndpointUpdateManyMutationInput!", "EndpointWhereInput"},
		"updateManyEndpoints")
	return &BatchPayloadExec{exec}
}

type EndpointUpsertParams struct {
	Where  EndpointWhereUniqueInput `json:"where"`
	Create EndpointCreateInput      `json:"create"`
	Update EndpointUpdateInput      `json:"update"`
}

func (client *Client) UpsertEndpoint(params EndpointUpsertParams) *EndpointExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EndpointWhereUniqueInput!", "EndpointCreateInput!", "EndpointUpdateInput!", "Endpoint"},
		"upsertEndpoint",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

func (client *Client) DeleteEndpoint(params EndpointWhereUniqueInput) *EndpointExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EndpointWhereUniqueInput!", "Endpoint"},
		"deleteEndpoint",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

func (client *Client) DeleteManyEndpoints(params *EndpointWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EndpointWhereInput", "deleteManyEndpoints")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFileHistory(params FileHistoryCreateInput) *FileHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"FileHistoryCreateInput!", "FileHistory"},
		"createFileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

type FileHistoryUpdateParams struct {
	Data  FileHistoryUpdateInput      `json:"data"`
	Where FileHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFileHistory(params FileHistoryUpdateParams) *FileHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FileHistoryUpdateInput!", "FileHistoryWhereUniqueInput!", "FileHistory"},
		"updateFileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

type FileHistoryUpdateManyParams struct {
	Data  FileHistoryUpdateManyMutationInput `json:"data"`
	Where *FileHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFileHistories(params FileHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FileHistoryUpdateManyMutationInput!", "FileHistoryWhereInput"},
		"updateManyFileHistories")
	return &BatchPayloadExec{exec}
}

type FileHistoryUpsertParams struct {
	Where  FileHistoryWhereUniqueInput `json:"where"`
	Create FileHistoryCreateInput      `json:"create"`
	Update FileHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertFileHistory(params FileHistoryUpsertParams) *FileHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FileHistoryWhereUniqueInput!", "FileHistoryCreateInput!", "FileHistoryUpdateInput!", "FileHistory"},
		"upsertFileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

func (client *Client) DeleteFileHistory(params FileHistoryWhereUniqueInput) *FileHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FileHistoryWhereUniqueInput!", "FileHistory"},
		"deleteFileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

func (client *Client) DeleteManyFileHistories(params *FileHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FileHistoryWhereInput", "deleteManyFileHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRule(params RuleCreateInput) *RuleExec {
	ret := client.Client.Create(
		params,
		[2]string{"RuleCreateInput!", "Rule"},
		"createRule",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

type RuleUpdateParams struct {
	Data  RuleUpdateInput      `json:"data"`
	Where RuleWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRule(params RuleUpdateParams) *RuleExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RuleUpdateInput!", "RuleWhereUniqueInput!", "Rule"},
		"updateRule",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

type RuleUpdateManyParams struct {
	Data  RuleUpdateManyMutationInput `json:"data"`
	Where *RuleWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRules(params RuleUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RuleUpdateManyMutationInput!", "RuleWhereInput"},
		"updateManyRules")
	return &BatchPayloadExec{exec}
}

type RuleUpsertParams struct {
	Where  RuleWhereUniqueInput `json:"where"`
	Create RuleCreateInput      `json:"create"`
	Update RuleUpdateInput      `json:"update"`
}

func (client *Client) UpsertRule(params RuleUpsertParams) *RuleExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RuleWhereUniqueInput!", "RuleCreateInput!", "RuleUpdateInput!", "Rule"},
		"upsertRule",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

func (client *Client) DeleteRule(params RuleWhereUniqueInput) *RuleExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RuleWhereUniqueInput!", "Rule"},
		"deleteRule",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

func (client *Client) DeleteManyRules(params *RuleWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RuleWhereInput", "deleteManyRules")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRuleResult(params RuleResultCreateInput) *RuleResultExec {
	ret := client.Client.Create(
		params,
		[2]string{"RuleResultCreateInput!", "RuleResult"},
		"createRuleResult",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

type RuleResultUpdateParams struct {
	Data  RuleResultUpdateInput      `json:"data"`
	Where RuleResultWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRuleResult(params RuleResultUpdateParams) *RuleResultExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RuleResultUpdateInput!", "RuleResultWhereUniqueInput!", "RuleResult"},
		"updateRuleResult",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

type RuleResultUpdateManyParams struct {
	Data  RuleResultUpdateManyMutationInput `json:"data"`
	Where *RuleResultWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRuleResults(params RuleResultUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RuleResultUpdateManyMutationInput!", "RuleResultWhereInput"},
		"updateManyRuleResults")
	return &BatchPayloadExec{exec}
}

type RuleResultUpsertParams struct {
	Where  RuleResultWhereUniqueInput `json:"where"`
	Create RuleResultCreateInput      `json:"create"`
	Update RuleResultUpdateInput      `json:"update"`
}

func (client *Client) UpsertRuleResult(params RuleResultUpsertParams) *RuleResultExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RuleResultWhereUniqueInput!", "RuleResultCreateInput!", "RuleResultUpdateInput!", "RuleResult"},
		"upsertRuleResult",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

func (client *Client) DeleteRuleResult(params RuleResultWhereUniqueInput) *RuleResultExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RuleResultWhereUniqueInput!", "RuleResult"},
		"deleteRuleResult",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

func (client *Client) DeleteManyRuleResults(params *RuleResultWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RuleResultWhereInput", "deleteManyRuleResults")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateScan(params ScanCreateInput) *ScanExec {
	ret := client.Client.Create(
		params,
		[2]string{"ScanCreateInput!", "Scan"},
		"createScan",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

type ScanUpdateParams struct {
	Data  ScanUpdateInput      `json:"data"`
	Where ScanWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateScan(params ScanUpdateParams) *ScanExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ScanUpdateInput!", "ScanWhereUniqueInput!", "Scan"},
		"updateScan",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

type ScanUpdateManyParams struct {
	Data  ScanUpdateManyMutationInput `json:"data"`
	Where *ScanWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyScans(params ScanUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ScanUpdateManyMutationInput!", "ScanWhereInput"},
		"updateManyScans")
	return &BatchPayloadExec{exec}
}

type ScanUpsertParams struct {
	Where  ScanWhereUniqueInput `json:"where"`
	Create ScanCreateInput      `json:"create"`
	Update ScanUpdateInput      `json:"update"`
}

func (client *Client) UpsertScan(params ScanUpsertParams) *ScanExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ScanWhereUniqueInput!", "ScanCreateInput!", "ScanUpdateInput!", "Scan"},
		"upsertScan",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

func (client *Client) DeleteScan(params ScanWhereUniqueInput) *ScanExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ScanWhereUniqueInput!", "Scan"},
		"deleteScan",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

func (client *Client) DeleteManyScans(params *ScanWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ScanWhereInput", "deleteManyScans")
	return &BatchPayloadExec{exec}
}

type DomainUserOrderByInput string

const (
	DomainUserOrderByInputSidAsc       DomainUserOrderByInput = "sid_ASC"
	DomainUserOrderByInputSidDesc      DomainUserOrderByInput = "sid_DESC"
	DomainUserOrderByInputGroupsAsc    DomainUserOrderByInput = "groups_ASC"
	DomainUserOrderByInputGroupsDesc   DomainUserOrderByInput = "groups_DESC"
	DomainUserOrderByInputNameAsc      DomainUserOrderByInput = "name_ASC"
	DomainUserOrderByInputNameDesc     DomainUserOrderByInput = "name_DESC"
	DomainUserOrderByInputUsernameAsc  DomainUserOrderByInput = "username_ASC"
	DomainUserOrderByInputUsernameDesc DomainUserOrderByInput = "username_DESC"
)

type EndpointOrderByInput string

const (
	EndpointOrderByInputEndpointIdAsc  EndpointOrderByInput = "endpoint_id_ASC"
	EndpointOrderByInputEndpointIdDesc EndpointOrderByInput = "endpoint_id_DESC"
	EndpointOrderByInputIgnoreAsc      EndpointOrderByInput = "ignore_ASC"
	EndpointOrderByInputIgnoreDesc     EndpointOrderByInput = "ignore_DESC"
	EndpointOrderByInputPathAsc        EndpointOrderByInput = "path_ASC"
	EndpointOrderByInputPathDesc       EndpointOrderByInput = "path_DESC"
	EndpointOrderByInputPrincipalAsc   EndpointOrderByInput = "principal_ASC"
	EndpointOrderByInputPrincipalDesc  EndpointOrderByInput = "principal_DESC"
)

type FileHistoryOrderByInput string

const (
	FileHistoryOrderByInputFileHistoryIdAsc  FileHistoryOrderByInput = "file_history_id_ASC"
	FileHistoryOrderByInputFileHistoryIdDesc FileHistoryOrderByInput = "file_history_id_DESC"
	FileHistoryOrderByInputActionAsc         FileHistoryOrderByInput = "action_ASC"
	FileHistoryOrderByInputActionDesc        FileHistoryOrderByInput = "action_DESC"
	FileHistoryOrderByInputActionTstampAsc   FileHistoryOrderByInput = "actionTstamp_ASC"
	FileHistoryOrderByInputActionTstampDesc  FileHistoryOrderByInput = "actionTstamp_DESC"
	FileHistoryOrderByInputFilenameAsc       FileHistoryOrderByInput = "filename_ASC"
	FileHistoryOrderByInputFilenameDesc      FileHistoryOrderByInput = "filename_DESC"
)

type RuleResultOrderByInput string

const (
	RuleResultOrderByInputRuleResultIdAsc  RuleResultOrderByInput = "rule_result_id_ASC"
	RuleResultOrderByInputRuleResultIdDesc RuleResultOrderByInput = "rule_result_id_DESC"
	RuleResultOrderByInputCreatedAtAsc     RuleResultOrderByInput = "createdAt_ASC"
	RuleResultOrderByInputCreatedAtDesc    RuleResultOrderByInput = "createdAt_DESC"
	RuleResultOrderByInputDataAsc          RuleResultOrderByInput = "data_ASC"
	RuleResultOrderByInputDataDesc         RuleResultOrderByInput = "data_DESC"
)

type RuleOrderByInput string

const (
	RuleOrderByInputRuleIdAsc     RuleOrderByInput = "rule_id_ASC"
	RuleOrderByInputRuleIdDesc    RuleOrderByInput = "rule_id_DESC"
	RuleOrderByInputIgnoreAsc     RuleOrderByInput = "ignore_ASC"
	RuleOrderByInputIgnoreDesc    RuleOrderByInput = "ignore_DESC"
	RuleOrderByInputPrincipalAsc  RuleOrderByInput = "principal_ASC"
	RuleOrderByInputPrincipalDesc RuleOrderByInput = "principal_DESC"
	RuleOrderByInputPriorityAsc   RuleOrderByInput = "priority_ASC"
	RuleOrderByInputPriorityDesc  RuleOrderByInput = "priority_DESC"
	RuleOrderByInputRuleAsc       RuleOrderByInput = "rule_ASC"
	RuleOrderByInputRuleDesc      RuleOrderByInput = "rule_DESC"
)

type ScanOrderByInput string

const (
	ScanOrderByInputScanIdAsc       ScanOrderByInput = "scan_id_ASC"
	ScanOrderByInputScanIdDesc      ScanOrderByInput = "scan_id_DESC"
	ScanOrderByInputCompletedAtAsc  ScanOrderByInput = "completedAt_ASC"
	ScanOrderByInputCompletedAtDesc ScanOrderByInput = "completedAt_DESC"
	ScanOrderByInputStartedAtAsc    ScanOrderByInput = "startedAt_ASC"
	ScanOrderByInputStartedAtDesc   ScanOrderByInput = "startedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type DomainUserWhereUniqueInput struct {
	Sid      *string `json:"sid,omitempty"`
	Username *string `json:"username,omitempty"`
}

type DomainUserWhereInput struct {
	Sid                   *string                `json:"sid,omitempty"`
	SidNot                *string                `json:"sid_not,omitempty"`
	SidIn                 []string               `json:"sid_in,omitempty"`
	SidNotIn              []string               `json:"sid_not_in,omitempty"`
	SidLt                 *string                `json:"sid_lt,omitempty"`
	SidLte                *string                `json:"sid_lte,omitempty"`
	SidGt                 *string                `json:"sid_gt,omitempty"`
	SidGte                *string                `json:"sid_gte,omitempty"`
	SidContains           *string                `json:"sid_contains,omitempty"`
	SidNotContains        *string                `json:"sid_not_contains,omitempty"`
	SidStartsWith         *string                `json:"sid_starts_with,omitempty"`
	SidNotStartsWith      *string                `json:"sid_not_starts_with,omitempty"`
	SidEndsWith           *string                `json:"sid_ends_with,omitempty"`
	SidNotEndsWith        *string                `json:"sid_not_ends_with,omitempty"`
	Name                  *string                `json:"name,omitempty"`
	NameNot               *string                `json:"name_not,omitempty"`
	NameIn                []string               `json:"name_in,omitempty"`
	NameNotIn             []string               `json:"name_not_in,omitempty"`
	NameLt                *string                `json:"name_lt,omitempty"`
	NameLte               *string                `json:"name_lte,omitempty"`
	NameGt                *string                `json:"name_gt,omitempty"`
	NameGte               *string                `json:"name_gte,omitempty"`
	NameContains          *string                `json:"name_contains,omitempty"`
	NameNotContains       *string                `json:"name_not_contains,omitempty"`
	NameStartsWith        *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string                `json:"name_not_ends_with,omitempty"`
	Username              *string                `json:"username,omitempty"`
	UsernameNot           *string                `json:"username_not,omitempty"`
	UsernameIn            []string               `json:"username_in,omitempty"`
	UsernameNotIn         []string               `json:"username_not_in,omitempty"`
	UsernameLt            *string                `json:"username_lt,omitempty"`
	UsernameLte           *string                `json:"username_lte,omitempty"`
	UsernameGt            *string                `json:"username_gt,omitempty"`
	UsernameGte           *string                `json:"username_gte,omitempty"`
	UsernameContains      *string                `json:"username_contains,omitempty"`
	UsernameNotContains   *string                `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string                `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string                `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string                `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string                `json:"username_not_ends_with,omitempty"`
	And                   []DomainUserWhereInput `json:"AND,omitempty"`
	Or                    []DomainUserWhereInput `json:"OR,omitempty"`
	Not                   []DomainUserWhereInput `json:"NOT,omitempty"`
}

type EndpointWhereUniqueInput struct {
	EndpointId *int32  `json:"endpoint_id,omitempty"`
	Path       *string `json:"path,omitempty"`
}

type EndpointWhereInput struct {
	EndpointId        *int32               `json:"endpoint_id,omitempty"`
	EndpointIdNot     *int32               `json:"endpoint_id_not,omitempty"`
	EndpointIdIn      []int32              `json:"endpoint_id_in,omitempty"`
	EndpointIdNotIn   []int32              `json:"endpoint_id_not_in,omitempty"`
	EndpointIdLt      *int32               `json:"endpoint_id_lt,omitempty"`
	EndpointIdLte     *int32               `json:"endpoint_id_lte,omitempty"`
	EndpointIdGt      *int32               `json:"endpoint_id_gt,omitempty"`
	EndpointIdGte     *int32               `json:"endpoint_id_gte,omitempty"`
	Ignore            *bool                `json:"ignore,omitempty"`
	IgnoreNot         *bool                `json:"ignore_not,omitempty"`
	Path              *string              `json:"path,omitempty"`
	PathNot           *string              `json:"path_not,omitempty"`
	PathIn            []string             `json:"path_in,omitempty"`
	PathNotIn         []string             `json:"path_not_in,omitempty"`
	PathLt            *string              `json:"path_lt,omitempty"`
	PathLte           *string              `json:"path_lte,omitempty"`
	PathGt            *string              `json:"path_gt,omitempty"`
	PathGte           *string              `json:"path_gte,omitempty"`
	PathContains      *string              `json:"path_contains,omitempty"`
	PathNotContains   *string              `json:"path_not_contains,omitempty"`
	PathStartsWith    *string              `json:"path_starts_with,omitempty"`
	PathNotStartsWith *string              `json:"path_not_starts_with,omitempty"`
	PathEndsWith      *string              `json:"path_ends_with,omitempty"`
	PathNotEndsWith   *string              `json:"path_not_ends_with,omitempty"`
	Principal         *int32               `json:"principal,omitempty"`
	PrincipalNot      *int32               `json:"principal_not,omitempty"`
	PrincipalIn       []int32              `json:"principal_in,omitempty"`
	PrincipalNotIn    []int32              `json:"principal_not_in,omitempty"`
	PrincipalLt       *int32               `json:"principal_lt,omitempty"`
	PrincipalLte      *int32               `json:"principal_lte,omitempty"`
	PrincipalGt       *int32               `json:"principal_gt,omitempty"`
	PrincipalGte      *int32               `json:"principal_gte,omitempty"`
	And               []EndpointWhereInput `json:"AND,omitempty"`
	Or                []EndpointWhereInput `json:"OR,omitempty"`
	Not               []EndpointWhereInput `json:"NOT,omitempty"`
}

type FileHistoryWhereUniqueInput struct {
	FileHistoryId *int32 `json:"file_history_id,omitempty"`
}

type FileHistoryWhereInput struct {
	FileHistoryId         *int32                  `json:"file_history_id,omitempty"`
	FileHistoryIdNot      *int32                  `json:"file_history_id_not,omitempty"`
	FileHistoryIdIn       []int32                 `json:"file_history_id_in,omitempty"`
	FileHistoryIdNotIn    []int32                 `json:"file_history_id_not_in,omitempty"`
	FileHistoryIdLt       *int32                  `json:"file_history_id_lt,omitempty"`
	FileHistoryIdLte      *int32                  `json:"file_history_id_lte,omitempty"`
	FileHistoryIdGt       *int32                  `json:"file_history_id_gt,omitempty"`
	FileHistoryIdGte      *int32                  `json:"file_history_id_gte,omitempty"`
	Action                *string                 `json:"action,omitempty"`
	ActionNot             *string                 `json:"action_not,omitempty"`
	ActionIn              []string                `json:"action_in,omitempty"`
	ActionNotIn           []string                `json:"action_not_in,omitempty"`
	ActionLt              *string                 `json:"action_lt,omitempty"`
	ActionLte             *string                 `json:"action_lte,omitempty"`
	ActionGt              *string                 `json:"action_gt,omitempty"`
	ActionGte             *string                 `json:"action_gte,omitempty"`
	ActionContains        *string                 `json:"action_contains,omitempty"`
	ActionNotContains     *string                 `json:"action_not_contains,omitempty"`
	ActionStartsWith      *string                 `json:"action_starts_with,omitempty"`
	ActionNotStartsWith   *string                 `json:"action_not_starts_with,omitempty"`
	ActionEndsWith        *string                 `json:"action_ends_with,omitempty"`
	ActionNotEndsWith     *string                 `json:"action_not_ends_with,omitempty"`
	ActionTstamp          *string                 `json:"actionTstamp,omitempty"`
	ActionTstampNot       *string                 `json:"actionTstamp_not,omitempty"`
	ActionTstampIn        []string                `json:"actionTstamp_in,omitempty"`
	ActionTstampNotIn     []string                `json:"actionTstamp_not_in,omitempty"`
	ActionTstampLt        *string                 `json:"actionTstamp_lt,omitempty"`
	ActionTstampLte       *string                 `json:"actionTstamp_lte,omitempty"`
	ActionTstampGt        *string                 `json:"actionTstamp_gt,omitempty"`
	ActionTstampGte       *string                 `json:"actionTstamp_gte,omitempty"`
	FileHistoryEvery      *FileHistoryWhereInput  `json:"fileHistory_every,omitempty"`
	FileHistorySome       *FileHistoryWhereInput  `json:"fileHistory_some,omitempty"`
	FileHistoryNone       *FileHistoryWhereInput  `json:"fileHistory_none,omitempty"`
	Filename              *string                 `json:"filename,omitempty"`
	FilenameNot           *string                 `json:"filename_not,omitempty"`
	FilenameIn            []string                `json:"filename_in,omitempty"`
	FilenameNotIn         []string                `json:"filename_not_in,omitempty"`
	FilenameLt            *string                 `json:"filename_lt,omitempty"`
	FilenameLte           *string                 `json:"filename_lte,omitempty"`
	FilenameGt            *string                 `json:"filename_gt,omitempty"`
	FilenameGte           *string                 `json:"filename_gte,omitempty"`
	FilenameContains      *string                 `json:"filename_contains,omitempty"`
	FilenameNotContains   *string                 `json:"filename_not_contains,omitempty"`
	FilenameStartsWith    *string                 `json:"filename_starts_with,omitempty"`
	FilenameNotStartsWith *string                 `json:"filename_not_starts_with,omitempty"`
	FilenameEndsWith      *string                 `json:"filename_ends_with,omitempty"`
	FilenameNotEndsWith   *string                 `json:"filename_not_ends_with,omitempty"`
	Prev                  *FileHistoryWhereInput  `json:"prev,omitempty"`
	RuleResultsEvery      *RuleResultWhereInput   `json:"ruleResults_every,omitempty"`
	RuleResultsSome       *RuleResultWhereInput   `json:"ruleResults_some,omitempty"`
	RuleResultsNone       *RuleResultWhereInput   `json:"ruleResults_none,omitempty"`
	Scan                  *ScanWhereInput         `json:"scan,omitempty"`
	And                   []FileHistoryWhereInput `json:"AND,omitempty"`
	Or                    []FileHistoryWhereInput `json:"OR,omitempty"`
	Not                   []FileHistoryWhereInput `json:"NOT,omitempty"`
}

type RuleResultWhereInput struct {
	RuleResultId      *int32                 `json:"rule_result_id,omitempty"`
	RuleResultIdNot   *int32                 `json:"rule_result_id_not,omitempty"`
	RuleResultIdIn    []int32                `json:"rule_result_id_in,omitempty"`
	RuleResultIdNotIn []int32                `json:"rule_result_id_not_in,omitempty"`
	RuleResultIdLt    *int32                 `json:"rule_result_id_lt,omitempty"`
	RuleResultIdLte   *int32                 `json:"rule_result_id_lte,omitempty"`
	RuleResultIdGt    *int32                 `json:"rule_result_id_gt,omitempty"`
	RuleResultIdGte   *int32                 `json:"rule_result_id_gte,omitempty"`
	CreatedAt         *string                `json:"createdAt,omitempty"`
	CreatedAtNot      *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                `json:"createdAt_gte,omitempty"`
	FileHistory       *FileHistoryWhereInput `json:"fileHistory,omitempty"`
	Rule              *RuleWhereInput        `json:"rule,omitempty"`
	And               []RuleResultWhereInput `json:"AND,omitempty"`
	Or                []RuleResultWhereInput `json:"OR,omitempty"`
	Not               []RuleResultWhereInput `json:"NOT,omitempty"`
}

type RuleWhereInput struct {
	RuleId            *int32                `json:"rule_id,omitempty"`
	RuleIdNot         *int32                `json:"rule_id_not,omitempty"`
	RuleIdIn          []int32               `json:"rule_id_in,omitempty"`
	RuleIdNotIn       []int32               `json:"rule_id_not_in,omitempty"`
	RuleIdLt          *int32                `json:"rule_id_lt,omitempty"`
	RuleIdLte         *int32                `json:"rule_id_lte,omitempty"`
	RuleIdGt          *int32                `json:"rule_id_gt,omitempty"`
	RuleIdGte         *int32                `json:"rule_id_gte,omitempty"`
	Ignore            *bool                 `json:"ignore,omitempty"`
	IgnoreNot         *bool                 `json:"ignore_not,omitempty"`
	Principal         *int32                `json:"principal,omitempty"`
	PrincipalNot      *int32                `json:"principal_not,omitempty"`
	PrincipalIn       []int32               `json:"principal_in,omitempty"`
	PrincipalNotIn    []int32               `json:"principal_not_in,omitempty"`
	PrincipalLt       *int32                `json:"principal_lt,omitempty"`
	PrincipalLte      *int32                `json:"principal_lte,omitempty"`
	PrincipalGt       *int32                `json:"principal_gt,omitempty"`
	PrincipalGte      *int32                `json:"principal_gte,omitempty"`
	Priority          *int32                `json:"priority,omitempty"`
	PriorityNot       *int32                `json:"priority_not,omitempty"`
	PriorityIn        []int32               `json:"priority_in,omitempty"`
	PriorityNotIn     []int32               `json:"priority_not_in,omitempty"`
	PriorityLt        *int32                `json:"priority_lt,omitempty"`
	PriorityLte       *int32                `json:"priority_lte,omitempty"`
	PriorityGt        *int32                `json:"priority_gt,omitempty"`
	PriorityGte       *int32                `json:"priority_gte,omitempty"`
	Rule              *string               `json:"rule,omitempty"`
	RuleNot           *string               `json:"rule_not,omitempty"`
	RuleIn            []string              `json:"rule_in,omitempty"`
	RuleNotIn         []string              `json:"rule_not_in,omitempty"`
	RuleLt            *string               `json:"rule_lt,omitempty"`
	RuleLte           *string               `json:"rule_lte,omitempty"`
	RuleGt            *string               `json:"rule_gt,omitempty"`
	RuleGte           *string               `json:"rule_gte,omitempty"`
	RuleContains      *string               `json:"rule_contains,omitempty"`
	RuleNotContains   *string               `json:"rule_not_contains,omitempty"`
	RuleStartsWith    *string               `json:"rule_starts_with,omitempty"`
	RuleNotStartsWith *string               `json:"rule_not_starts_with,omitempty"`
	RuleEndsWith      *string               `json:"rule_ends_with,omitempty"`
	RuleNotEndsWith   *string               `json:"rule_not_ends_with,omitempty"`
	RuleResultsEvery  *RuleResultWhereInput `json:"ruleResults_every,omitempty"`
	RuleResultsSome   *RuleResultWhereInput `json:"ruleResults_some,omitempty"`
	RuleResultsNone   *RuleResultWhereInput `json:"ruleResults_none,omitempty"`
	And               []RuleWhereInput      `json:"AND,omitempty"`
	Or                []RuleWhereInput      `json:"OR,omitempty"`
	Not               []RuleWhereInput      `json:"NOT,omitempty"`
}

type ScanWhereInput struct {
	ScanId           *int32                 `json:"scan_id,omitempty"`
	ScanIdNot        *int32                 `json:"scan_id_not,omitempty"`
	ScanIdIn         []int32                `json:"scan_id_in,omitempty"`
	ScanIdNotIn      []int32                `json:"scan_id_not_in,omitempty"`
	ScanIdLt         *int32                 `json:"scan_id_lt,omitempty"`
	ScanIdLte        *int32                 `json:"scan_id_lte,omitempty"`
	ScanIdGt         *int32                 `json:"scan_id_gt,omitempty"`
	ScanIdGte        *int32                 `json:"scan_id_gte,omitempty"`
	CompletedAt      *string                `json:"completedAt,omitempty"`
	CompletedAtNot   *string                `json:"completedAt_not,omitempty"`
	CompletedAtIn    []string               `json:"completedAt_in,omitempty"`
	CompletedAtNotIn []string               `json:"completedAt_not_in,omitempty"`
	CompletedAtLt    *string                `json:"completedAt_lt,omitempty"`
	CompletedAtLte   *string                `json:"completedAt_lte,omitempty"`
	CompletedAtGt    *string                `json:"completedAt_gt,omitempty"`
	CompletedAtGte   *string                `json:"completedAt_gte,omitempty"`
	FileHistoryEvery *FileHistoryWhereInput `json:"fileHistory_every,omitempty"`
	FileHistorySome  *FileHistoryWhereInput `json:"fileHistory_some,omitempty"`
	FileHistoryNone  *FileHistoryWhereInput `json:"fileHistory_none,omitempty"`
	StartedAt        *string                `json:"startedAt,omitempty"`
	StartedAtNot     *string                `json:"startedAt_not,omitempty"`
	StartedAtIn      []string               `json:"startedAt_in,omitempty"`
	StartedAtNotIn   []string               `json:"startedAt_not_in,omitempty"`
	StartedAtLt      *string                `json:"startedAt_lt,omitempty"`
	StartedAtLte     *string                `json:"startedAt_lte,omitempty"`
	StartedAtGt      *string                `json:"startedAt_gt,omitempty"`
	StartedAtGte     *string                `json:"startedAt_gte,omitempty"`
	And              []ScanWhereInput       `json:"AND,omitempty"`
	Or               []ScanWhereInput       `json:"OR,omitempty"`
	Not              []ScanWhereInput       `json:"NOT,omitempty"`
}

type RuleWhereUniqueInput struct {
	RuleId *int32 `json:"rule_id,omitempty"`
}

type RuleResultWhereUniqueInput struct {
	RuleResultId *int32 `json:"rule_result_id,omitempty"`
}

type ScanWhereUniqueInput struct {
	ScanId *int32 `json:"scan_id,omitempty"`
}

type DomainUserCreateInput struct {
	Sid      *string                `json:"sid,omitempty"`
	Groups   map[string]interface{} `json:"groups"`
	Name     string                 `json:"name"`
	Username string                 `json:"username"`
}

type DomainUserUpdateInput struct {
	Groups   *map[string]interface{} `json:"groups,omitempty"`
	Name     *string                 `json:"name,omitempty"`
	Username *string                 `json:"username,omitempty"`
}

type DomainUserUpdateManyMutationInput struct {
	Groups   *map[string]interface{} `json:"groups,omitempty"`
	Name     *string                 `json:"name,omitempty"`
	Username *string                 `json:"username,omitempty"`
}

type EndpointCreateInput struct {
	Ignore    *bool  `json:"ignore,omitempty"`
	Path      string `json:"path"`
	Principal *int32 `json:"principal,omitempty"`
}

type EndpointUpdateInput struct {
	Ignore    *bool   `json:"ignore,omitempty"`
	Path      *string `json:"path,omitempty"`
	Principal *int32  `json:"principal,omitempty"`
}

type EndpointUpdateManyMutationInput struct {
	Ignore    *bool   `json:"ignore,omitempty"`
	Path      *string `json:"path,omitempty"`
	Principal *int32  `json:"principal,omitempty"`
}

type FileHistoryCreateInput struct {
	Action       string                                       `json:"action"`
	ActionTstamp string                                       `json:"actionTstamp"`
	FileHistory  *FileHistoryCreateManyInput                  `json:"fileHistory,omitempty"`
	Filename     string                                       `json:"filename"`
	Prev         FileHistoryCreateOneInput                    `json:"prev"`
	RuleResults  *RuleResultCreateManyWithoutFileHistoryInput `json:"ruleResults,omitempty"`
	Scan         ScanCreateOneWithoutFileHistoryInput         `json:"scan"`
}

type FileHistoryCreateManyInput struct {
	Create  []FileHistoryCreateInput      `json:"create,omitempty"`
	Connect []FileHistoryWhereUniqueInput `json:"connect,omitempty"`
}

type FileHistoryCreateOneInput struct {
	Create  *FileHistoryCreateInput      `json:"create,omitempty"`
	Connect *FileHistoryWhereUniqueInput `json:"connect,omitempty"`
}

type RuleResultCreateManyWithoutFileHistoryInput struct {
	Create  []RuleResultCreateWithoutFileHistoryInput `json:"create,omitempty"`
	Connect []RuleResultWhereUniqueInput              `json:"connect,omitempty"`
}

type RuleResultCreateWithoutFileHistoryInput struct {
	Data *map[string]interface{}              `json:"data,omitempty"`
	Rule RuleCreateOneWithoutRuleResultsInput `json:"rule"`
}

type RuleCreateOneWithoutRuleResultsInput struct {
	Create  *RuleCreateWithoutRuleResultsInput `json:"create,omitempty"`
	Connect *RuleWhereUniqueInput              `json:"connect,omitempty"`
}

type RuleCreateWithoutRuleResultsInput struct {
	Ignore    *bool  `json:"ignore,omitempty"`
	Principal *int32 `json:"principal,omitempty"`
	Priority  int32  `json:"priority"`
	Rule      string `json:"rule"`
}

type ScanCreateOneWithoutFileHistoryInput struct {
	Create  *ScanCreateWithoutFileHistoryInput `json:"create,omitempty"`
	Connect *ScanWhereUniqueInput              `json:"connect,omitempty"`
}

type ScanCreateWithoutFileHistoryInput struct {
	CompletedAt *string `json:"completedAt,omitempty"`
	StartedAt   string  `json:"startedAt"`
}

type FileHistoryUpdateInput struct {
	Action       *string                                       `json:"action,omitempty"`
	ActionTstamp *string                                       `json:"actionTstamp,omitempty"`
	FileHistory  *FileHistoryUpdateManyInput                   `json:"fileHistory,omitempty"`
	Filename     *string                                       `json:"filename,omitempty"`
	Prev         *FileHistoryUpdateOneRequiredInput            `json:"prev,omitempty"`
	RuleResults  *RuleResultUpdateManyWithoutFileHistoryInput  `json:"ruleResults,omitempty"`
	Scan         *ScanUpdateOneRequiredWithoutFileHistoryInput `json:"scan,omitempty"`
}

type FileHistoryUpdateManyInput struct {
	Create     []FileHistoryCreateInput                      `json:"create,omitempty"`
	Update     []FileHistoryUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []FileHistoryUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []FileHistoryWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []FileHistoryWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []FileHistoryWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []FileHistoryWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []FileHistoryScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []FileHistoryUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type FileHistoryUpdateWithWhereUniqueNestedInput struct {
	Where FileHistoryWhereUniqueInput `json:"where"`
	Data  FileHistoryUpdateDataInput  `json:"data"`
}

type FileHistoryUpdateDataInput struct {
	Action       *string                                       `json:"action,omitempty"`
	ActionTstamp *string                                       `json:"actionTstamp,omitempty"`
	FileHistory  *FileHistoryUpdateManyInput                   `json:"fileHistory,omitempty"`
	Filename     *string                                       `json:"filename,omitempty"`
	Prev         *FileHistoryUpdateOneRequiredInput            `json:"prev,omitempty"`
	RuleResults  *RuleResultUpdateManyWithoutFileHistoryInput  `json:"ruleResults,omitempty"`
	Scan         *ScanUpdateOneRequiredWithoutFileHistoryInput `json:"scan,omitempty"`
}

type FileHistoryUpdateOneRequiredInput struct {
	Create  *FileHistoryCreateInput       `json:"create,omitempty"`
	Update  *FileHistoryUpdateDataInput   `json:"update,omitempty"`
	Upsert  *FileHistoryUpsertNestedInput `json:"upsert,omitempty"`
	Connect *FileHistoryWhereUniqueInput  `json:"connect,omitempty"`
}

type FileHistoryUpsertNestedInput struct {
	Update FileHistoryUpdateDataInput `json:"update"`
	Create FileHistoryCreateInput     `json:"create"`
}

type RuleResultUpdateManyWithoutFileHistoryInput struct {
	Create     []RuleResultCreateWithoutFileHistoryInput                `json:"create,omitempty"`
	Delete     []RuleResultWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []RuleResultWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []RuleResultWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []RuleResultWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []RuleResultUpdateWithWhereUniqueWithoutFileHistoryInput `json:"update,omitempty"`
	Upsert     []RuleResultUpsertWithWhereUniqueWithoutFileHistoryInput `json:"upsert,omitempty"`
	DeleteMany []RuleResultScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []RuleResultUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type RuleResultUpdateWithWhereUniqueWithoutFileHistoryInput struct {
	Where RuleResultWhereUniqueInput                  `json:"where"`
	Data  RuleResultUpdateWithoutFileHistoryDataInput `json:"data"`
}

type RuleResultUpdateWithoutFileHistoryDataInput struct {
	Data *map[string]interface{}                       `json:"data,omitempty"`
	Rule *RuleUpdateOneRequiredWithoutRuleResultsInput `json:"rule,omitempty"`
}

type RuleUpdateOneRequiredWithoutRuleResultsInput struct {
	Create  *RuleCreateWithoutRuleResultsInput     `json:"create,omitempty"`
	Update  *RuleUpdateWithoutRuleResultsDataInput `json:"update,omitempty"`
	Upsert  *RuleUpsertWithoutRuleResultsInput     `json:"upsert,omitempty"`
	Connect *RuleWhereUniqueInput                  `json:"connect,omitempty"`
}

type RuleUpdateWithoutRuleResultsDataInput struct {
	Ignore    *bool   `json:"ignore,omitempty"`
	Principal *int32  `json:"principal,omitempty"`
	Priority  *int32  `json:"priority,omitempty"`
	Rule      *string `json:"rule,omitempty"`
}

type RuleUpsertWithoutRuleResultsInput struct {
	Update RuleUpdateWithoutRuleResultsDataInput `json:"update"`
	Create RuleCreateWithoutRuleResultsInput     `json:"create"`
}

type RuleResultUpsertWithWhereUniqueWithoutFileHistoryInput struct {
	Where  RuleResultWhereUniqueInput                  `json:"where"`
	Update RuleResultUpdateWithoutFileHistoryDataInput `json:"update"`
	Create RuleResultCreateWithoutFileHistoryInput     `json:"create"`
}

type RuleResultScalarWhereInput struct {
	RuleResultId      *int32                       `json:"rule_result_id,omitempty"`
	RuleResultIdNot   *int32                       `json:"rule_result_id_not,omitempty"`
	RuleResultIdIn    []int32                      `json:"rule_result_id_in,omitempty"`
	RuleResultIdNotIn []int32                      `json:"rule_result_id_not_in,omitempty"`
	RuleResultIdLt    *int32                       `json:"rule_result_id_lt,omitempty"`
	RuleResultIdLte   *int32                       `json:"rule_result_id_lte,omitempty"`
	RuleResultIdGt    *int32                       `json:"rule_result_id_gt,omitempty"`
	RuleResultIdGte   *int32                       `json:"rule_result_id_gte,omitempty"`
	CreatedAt         *string                      `json:"createdAt,omitempty"`
	CreatedAtNot      *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                      `json:"createdAt_gte,omitempty"`
	And               []RuleResultScalarWhereInput `json:"AND,omitempty"`
	Or                []RuleResultScalarWhereInput `json:"OR,omitempty"`
	Not               []RuleResultScalarWhereInput `json:"NOT,omitempty"`
}

type RuleResultUpdateManyWithWhereNestedInput struct {
	Where RuleResultScalarWhereInput    `json:"where"`
	Data  RuleResultUpdateManyDataInput `json:"data"`
}

type RuleResultUpdateManyDataInput struct {
	Data *map[string]interface{} `json:"data,omitempty"`
}

type ScanUpdateOneRequiredWithoutFileHistoryInput struct {
	Create  *ScanCreateWithoutFileHistoryInput     `json:"create,omitempty"`
	Update  *ScanUpdateWithoutFileHistoryDataInput `json:"update,omitempty"`
	Upsert  *ScanUpsertWithoutFileHistoryInput     `json:"upsert,omitempty"`
	Connect *ScanWhereUniqueInput                  `json:"connect,omitempty"`
}

type ScanUpdateWithoutFileHistoryDataInput struct {
	CompletedAt *string `json:"completedAt,omitempty"`
	StartedAt   *string `json:"startedAt,omitempty"`
}

type ScanUpsertWithoutFileHistoryInput struct {
	Update ScanUpdateWithoutFileHistoryDataInput `json:"update"`
	Create ScanCreateWithoutFileHistoryInput     `json:"create"`
}

type FileHistoryUpsertWithWhereUniqueNestedInput struct {
	Where  FileHistoryWhereUniqueInput `json:"where"`
	Update FileHistoryUpdateDataInput  `json:"update"`
	Create FileHistoryCreateInput      `json:"create"`
}

type FileHistoryScalarWhereInput struct {
	FileHistoryId         *int32                        `json:"file_history_id,omitempty"`
	FileHistoryIdNot      *int32                        `json:"file_history_id_not,omitempty"`
	FileHistoryIdIn       []int32                       `json:"file_history_id_in,omitempty"`
	FileHistoryIdNotIn    []int32                       `json:"file_history_id_not_in,omitempty"`
	FileHistoryIdLt       *int32                        `json:"file_history_id_lt,omitempty"`
	FileHistoryIdLte      *int32                        `json:"file_history_id_lte,omitempty"`
	FileHistoryIdGt       *int32                        `json:"file_history_id_gt,omitempty"`
	FileHistoryIdGte      *int32                        `json:"file_history_id_gte,omitempty"`
	Action                *string                       `json:"action,omitempty"`
	ActionNot             *string                       `json:"action_not,omitempty"`
	ActionIn              []string                      `json:"action_in,omitempty"`
	ActionNotIn           []string                      `json:"action_not_in,omitempty"`
	ActionLt              *string                       `json:"action_lt,omitempty"`
	ActionLte             *string                       `json:"action_lte,omitempty"`
	ActionGt              *string                       `json:"action_gt,omitempty"`
	ActionGte             *string                       `json:"action_gte,omitempty"`
	ActionContains        *string                       `json:"action_contains,omitempty"`
	ActionNotContains     *string                       `json:"action_not_contains,omitempty"`
	ActionStartsWith      *string                       `json:"action_starts_with,omitempty"`
	ActionNotStartsWith   *string                       `json:"action_not_starts_with,omitempty"`
	ActionEndsWith        *string                       `json:"action_ends_with,omitempty"`
	ActionNotEndsWith     *string                       `json:"action_not_ends_with,omitempty"`
	ActionTstamp          *string                       `json:"actionTstamp,omitempty"`
	ActionTstampNot       *string                       `json:"actionTstamp_not,omitempty"`
	ActionTstampIn        []string                      `json:"actionTstamp_in,omitempty"`
	ActionTstampNotIn     []string                      `json:"actionTstamp_not_in,omitempty"`
	ActionTstampLt        *string                       `json:"actionTstamp_lt,omitempty"`
	ActionTstampLte       *string                       `json:"actionTstamp_lte,omitempty"`
	ActionTstampGt        *string                       `json:"actionTstamp_gt,omitempty"`
	ActionTstampGte       *string                       `json:"actionTstamp_gte,omitempty"`
	Filename              *string                       `json:"filename,omitempty"`
	FilenameNot           *string                       `json:"filename_not,omitempty"`
	FilenameIn            []string                      `json:"filename_in,omitempty"`
	FilenameNotIn         []string                      `json:"filename_not_in,omitempty"`
	FilenameLt            *string                       `json:"filename_lt,omitempty"`
	FilenameLte           *string                       `json:"filename_lte,omitempty"`
	FilenameGt            *string                       `json:"filename_gt,omitempty"`
	FilenameGte           *string                       `json:"filename_gte,omitempty"`
	FilenameContains      *string                       `json:"filename_contains,omitempty"`
	FilenameNotContains   *string                       `json:"filename_not_contains,omitempty"`
	FilenameStartsWith    *string                       `json:"filename_starts_with,omitempty"`
	FilenameNotStartsWith *string                       `json:"filename_not_starts_with,omitempty"`
	FilenameEndsWith      *string                       `json:"filename_ends_with,omitempty"`
	FilenameNotEndsWith   *string                       `json:"filename_not_ends_with,omitempty"`
	And                   []FileHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                    []FileHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                   []FileHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type FileHistoryUpdateManyWithWhereNestedInput struct {
	Where FileHistoryScalarWhereInput    `json:"where"`
	Data  FileHistoryUpdateManyDataInput `json:"data"`
}

type FileHistoryUpdateManyDataInput struct {
	Action       *string `json:"action,omitempty"`
	ActionTstamp *string `json:"actionTstamp,omitempty"`
	Filename     *string `json:"filename,omitempty"`
}

type FileHistoryUpdateManyMutationInput struct {
	Action       *string `json:"action,omitempty"`
	ActionTstamp *string `json:"actionTstamp,omitempty"`
	Filename     *string `json:"filename,omitempty"`
}

type RuleCreateInput struct {
	Ignore      *bool                                 `json:"ignore,omitempty"`
	Principal   *int32                                `json:"principal,omitempty"`
	Priority    int32                                 `json:"priority"`
	Rule        string                                `json:"rule"`
	RuleResults *RuleResultCreateManyWithoutRuleInput `json:"ruleResults,omitempty"`
}

type RuleResultCreateManyWithoutRuleInput struct {
	Create  []RuleResultCreateWithoutRuleInput `json:"create,omitempty"`
	Connect []RuleResultWhereUniqueInput       `json:"connect,omitempty"`
}

type RuleResultCreateWithoutRuleInput struct {
	Data        *map[string]interface{}                     `json:"data,omitempty"`
	FileHistory FileHistoryCreateOneWithoutRuleResultsInput `json:"fileHistory"`
}

type FileHistoryCreateOneWithoutRuleResultsInput struct {
	Create  *FileHistoryCreateWithoutRuleResultsInput `json:"create,omitempty"`
	Connect *FileHistoryWhereUniqueInput              `json:"connect,omitempty"`
}

type FileHistoryCreateWithoutRuleResultsInput struct {
	Action       string                               `json:"action"`
	ActionTstamp string                               `json:"actionTstamp"`
	FileHistory  *FileHistoryCreateManyInput          `json:"fileHistory,omitempty"`
	Filename     string                               `json:"filename"`
	Prev         FileHistoryCreateOneInput            `json:"prev"`
	Scan         ScanCreateOneWithoutFileHistoryInput `json:"scan"`
}

type RuleUpdateInput struct {
	Ignore      *bool                                 `json:"ignore,omitempty"`
	Principal   *int32                                `json:"principal,omitempty"`
	Priority    *int32                                `json:"priority,omitempty"`
	Rule        *string                               `json:"rule,omitempty"`
	RuleResults *RuleResultUpdateManyWithoutRuleInput `json:"ruleResults,omitempty"`
}

type RuleResultUpdateManyWithoutRuleInput struct {
	Create     []RuleResultCreateWithoutRuleInput                `json:"create,omitempty"`
	Delete     []RuleResultWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []RuleResultWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []RuleResultWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []RuleResultWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []RuleResultUpdateWithWhereUniqueWithoutRuleInput `json:"update,omitempty"`
	Upsert     []RuleResultUpsertWithWhereUniqueWithoutRuleInput `json:"upsert,omitempty"`
	DeleteMany []RuleResultScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []RuleResultUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type RuleResultUpdateWithWhereUniqueWithoutRuleInput struct {
	Where RuleResultWhereUniqueInput           `json:"where"`
	Data  RuleResultUpdateWithoutRuleDataInput `json:"data"`
}

type RuleResultUpdateWithoutRuleDataInput struct {
	Data        *map[string]interface{}                              `json:"data,omitempty"`
	FileHistory *FileHistoryUpdateOneRequiredWithoutRuleResultsInput `json:"fileHistory,omitempty"`
}

type FileHistoryUpdateOneRequiredWithoutRuleResultsInput struct {
	Create  *FileHistoryCreateWithoutRuleResultsInput     `json:"create,omitempty"`
	Update  *FileHistoryUpdateWithoutRuleResultsDataInput `json:"update,omitempty"`
	Upsert  *FileHistoryUpsertWithoutRuleResultsInput     `json:"upsert,omitempty"`
	Connect *FileHistoryWhereUniqueInput                  `json:"connect,omitempty"`
}

type FileHistoryUpdateWithoutRuleResultsDataInput struct {
	Action       *string                                       `json:"action,omitempty"`
	ActionTstamp *string                                       `json:"actionTstamp,omitempty"`
	FileHistory  *FileHistoryUpdateManyInput                   `json:"fileHistory,omitempty"`
	Filename     *string                                       `json:"filename,omitempty"`
	Prev         *FileHistoryUpdateOneRequiredInput            `json:"prev,omitempty"`
	Scan         *ScanUpdateOneRequiredWithoutFileHistoryInput `json:"scan,omitempty"`
}

type FileHistoryUpsertWithoutRuleResultsInput struct {
	Update FileHistoryUpdateWithoutRuleResultsDataInput `json:"update"`
	Create FileHistoryCreateWithoutRuleResultsInput     `json:"create"`
}

type RuleResultUpsertWithWhereUniqueWithoutRuleInput struct {
	Where  RuleResultWhereUniqueInput           `json:"where"`
	Update RuleResultUpdateWithoutRuleDataInput `json:"update"`
	Create RuleResultCreateWithoutRuleInput     `json:"create"`
}

type RuleUpdateManyMutationInput struct {
	Ignore    *bool   `json:"ignore,omitempty"`
	Principal *int32  `json:"principal,omitempty"`
	Priority  *int32  `json:"priority,omitempty"`
	Rule      *string `json:"rule,omitempty"`
}

type RuleResultCreateInput struct {
	Data        *map[string]interface{}                     `json:"data,omitempty"`
	FileHistory FileHistoryCreateOneWithoutRuleResultsInput `json:"fileHistory"`
	Rule        RuleCreateOneWithoutRuleResultsInput        `json:"rule"`
}

type RuleResultUpdateInput struct {
	Data        *map[string]interface{}                              `json:"data,omitempty"`
	FileHistory *FileHistoryUpdateOneRequiredWithoutRuleResultsInput `json:"fileHistory,omitempty"`
	Rule        *RuleUpdateOneRequiredWithoutRuleResultsInput        `json:"rule,omitempty"`
}

type RuleResultUpdateManyMutationInput struct {
	Data *map[string]interface{} `json:"data,omitempty"`
}

type ScanCreateInput struct {
	CompletedAt *string                                `json:"completedAt,omitempty"`
	FileHistory *FileHistoryCreateManyWithoutScanInput `json:"fileHistory,omitempty"`
	StartedAt   string                                 `json:"startedAt"`
}

type FileHistoryCreateManyWithoutScanInput struct {
	Create  []FileHistoryCreateWithoutScanInput `json:"create,omitempty"`
	Connect []FileHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type FileHistoryCreateWithoutScanInput struct {
	Action       string                                       `json:"action"`
	ActionTstamp string                                       `json:"actionTstamp"`
	FileHistory  *FileHistoryCreateManyInput                  `json:"fileHistory,omitempty"`
	Filename     string                                       `json:"filename"`
	Prev         FileHistoryCreateOneInput                    `json:"prev"`
	RuleResults  *RuleResultCreateManyWithoutFileHistoryInput `json:"ruleResults,omitempty"`
}

type ScanUpdateInput struct {
	CompletedAt *string                                `json:"completedAt,omitempty"`
	FileHistory *FileHistoryUpdateManyWithoutScanInput `json:"fileHistory,omitempty"`
	StartedAt   *string                                `json:"startedAt,omitempty"`
}

type FileHistoryUpdateManyWithoutScanInput struct {
	Create     []FileHistoryCreateWithoutScanInput                `json:"create,omitempty"`
	Delete     []FileHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []FileHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []FileHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []FileHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []FileHistoryUpdateWithWhereUniqueWithoutScanInput `json:"update,omitempty"`
	Upsert     []FileHistoryUpsertWithWhereUniqueWithoutScanInput `json:"upsert,omitempty"`
	DeleteMany []FileHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []FileHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type FileHistoryUpdateWithWhereUniqueWithoutScanInput struct {
	Where FileHistoryWhereUniqueInput           `json:"where"`
	Data  FileHistoryUpdateWithoutScanDataInput `json:"data"`
}

type FileHistoryUpdateWithoutScanDataInput struct {
	Action       *string                                      `json:"action,omitempty"`
	ActionTstamp *string                                      `json:"actionTstamp,omitempty"`
	FileHistory  *FileHistoryUpdateManyInput                  `json:"fileHistory,omitempty"`
	Filename     *string                                      `json:"filename,omitempty"`
	Prev         *FileHistoryUpdateOneRequiredInput           `json:"prev,omitempty"`
	RuleResults  *RuleResultUpdateManyWithoutFileHistoryInput `json:"ruleResults,omitempty"`
}

type FileHistoryUpsertWithWhereUniqueWithoutScanInput struct {
	Where  FileHistoryWhereUniqueInput           `json:"where"`
	Update FileHistoryUpdateWithoutScanDataInput `json:"update"`
	Create FileHistoryCreateWithoutScanInput     `json:"create"`
}

type ScanUpdateManyMutationInput struct {
	CompletedAt *string `json:"completedAt,omitempty"`
	StartedAt   *string `json:"startedAt,omitempty"`
}

type DomainUserSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *DomainUserWhereInput              `json:"node,omitempty"`
	And                        []DomainUserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []DomainUserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []DomainUserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EndpointSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *EndpointWhereInput              `json:"node,omitempty"`
	And                        []EndpointSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EndpointSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EndpointSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FileHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *FileHistoryWhereInput              `json:"node,omitempty"`
	And                        []FileHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FileHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FileHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type RuleSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *RuleWhereInput              `json:"node,omitempty"`
	And                        []RuleSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RuleSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RuleSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RuleResultSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *RuleResultWhereInput              `json:"node,omitempty"`
	And                        []RuleResultSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RuleResultSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RuleResultSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ScanSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *ScanWhereInput              `json:"node,omitempty"`
	And                        []ScanSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ScanSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ScanSubscriptionWhereInput `json:"NOT,omitempty"`
}

type DomainUserExec struct {
	exec *prisma.Exec
}

func (instance DomainUserExec) Exec(ctx context.Context) (*DomainUser, error) {
	var v DomainUser
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainUserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainUserExecArray struct {
	exec *prisma.Exec
}

func (instance DomainUserExecArray) Exec(ctx context.Context) ([]DomainUser, error) {
	var v []DomainUser
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DomainUser struct {
	Sid      string                 `json:"sid"`
	Groups   map[string]interface{} `json:"groups"`
	Name     string                 `json:"name"`
	Username string                 `json:"username"`
}

type DomainUserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *DomainUserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *DomainUserConnectionExec) Edges() *DomainUserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DomainUserEdge"},
		"edges",
		[]string{"cursor"})

	return &DomainUserEdgeExec{ret}
}

func (instance *DomainUserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateDomainUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance DomainUserConnectionExec) Exec(ctx context.Context) (*DomainUserConnection, error) {
	var v DomainUserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainUserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainUserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance DomainUserConnectionExecArray) Exec(ctx context.Context) ([]DomainUserConnection, error) {
	var v []DomainUserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DomainUserConnection struct {
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type DomainUserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *DomainUserEdgeExec) Node() *DomainUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DomainUser"},
		"node",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

func (instance DomainUserEdgeExec) Exec(ctx context.Context) (*DomainUserEdge, error) {
	var v DomainUserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainUserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainUserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance DomainUserEdgeExecArray) Exec(ctx context.Context) ([]DomainUserEdge, error) {
	var v []DomainUserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DomainUserEdge struct {
	Cursor string `json:"cursor"`
}

type EndpointExec struct {
	exec *prisma.Exec
}

func (instance EndpointExec) Exec(ctx context.Context) (*Endpoint, error) {
	var v Endpoint
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EndpointExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EndpointExecArray struct {
	exec *prisma.Exec
}

func (instance EndpointExecArray) Exec(ctx context.Context) ([]Endpoint, error) {
	var v []Endpoint
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Endpoint struct {
	EndpointId int32  `json:"endpoint_id"`
	Ignore     bool   `json:"ignore"`
	Path       string `json:"path"`
	Principal  *int32 `json:"principal,omitempty"`
}

type EndpointConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EndpointConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EndpointConnectionExec) Edges() *EndpointEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EndpointEdge"},
		"edges",
		[]string{"cursor"})

	return &EndpointEdgeExec{ret}
}

func (instance *EndpointConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEndpoint"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance EndpointConnectionExec) Exec(ctx context.Context) (*EndpointConnection, error) {
	var v EndpointConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EndpointConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EndpointConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EndpointConnectionExecArray) Exec(ctx context.Context) ([]EndpointConnection, error) {
	var v []EndpointConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EndpointConnection struct {
}

type EndpointEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EndpointEdgeExec) Node() *EndpointExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Endpoint"},
		"node",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

func (instance EndpointEdgeExec) Exec(ctx context.Context) (*EndpointEdge, error) {
	var v EndpointEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EndpointEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EndpointEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EndpointEdgeExecArray) Exec(ctx context.Context) ([]EndpointEdge, error) {
	var v []EndpointEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EndpointEdge struct {
	Cursor string `json:"cursor"`
}

type FileHistoryExec struct {
	exec *prisma.Exec
}

type FileHistoryParamsExec struct {
	Where   *FileHistoryWhereInput
	OrderBy *FileHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FileHistoryExec) FileHistory(params *FileHistoryParamsExec) *FileHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FileHistoryWhereInput", "FileHistoryOrderByInput", "FileHistory"},
		"fileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExecArray{ret}
}

func (instance *FileHistoryExec) Prev() *FileHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileHistory"},
		"prev",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

type RuleResultsParamsExec struct {
	Where   *RuleResultWhereInput
	OrderBy *RuleResultOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FileHistoryExec) RuleResults(params *RuleResultsParamsExec) *RuleResultExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RuleResultWhereInput", "RuleResultOrderByInput", "RuleResult"},
		"ruleResults",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExecArray{ret}
}

func (instance *FileHistoryExec) Scan() *ScanExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Scan"},
		"scan",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

func (instance FileHistoryExec) Exec(ctx context.Context) (*FileHistory, error) {
	var v FileHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance FileHistoryExecArray) Exec(ctx context.Context) ([]FileHistory, error) {
	var v []FileHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileHistory struct {
	FileHistoryId int32  `json:"file_history_id"`
	Action        string `json:"action"`
	ActionTstamp  string `json:"actionTstamp"`
	Filename      string `json:"filename"`
}

type RuleResultExec struct {
	exec *prisma.Exec
}

func (instance *RuleResultExec) FileHistory() *FileHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileHistory"},
		"fileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

func (instance *RuleResultExec) Rule() *RuleExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Rule"},
		"rule",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

func (instance RuleResultExec) Exec(ctx context.Context) (*RuleResult, error) {
	var v RuleResult
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleResultExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleResultExecArray struct {
	exec *prisma.Exec
}

func (instance RuleResultExecArray) Exec(ctx context.Context) ([]RuleResult, error) {
	var v []RuleResult
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleResult struct {
	RuleResultId int32                   `json:"rule_result_id"`
	CreatedAt    string                  `json:"createdAt"`
	Data         *map[string]interface{} `json:"data,omitempty"`
}

type RuleExec struct {
	exec *prisma.Exec
}

func (instance *RuleExec) RuleResults(params *RuleResultsParamsExec) *RuleResultExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RuleResultWhereInput", "RuleResultOrderByInput", "RuleResult"},
		"ruleResults",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExecArray{ret}
}

func (instance RuleExec) Exec(ctx context.Context) (*Rule, error) {
	var v Rule
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleExecArray struct {
	exec *prisma.Exec
}

func (instance RuleExecArray) Exec(ctx context.Context) ([]Rule, error) {
	var v []Rule
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Rule struct {
	RuleId    int32  `json:"rule_id"`
	Ignore    bool   `json:"ignore"`
	Principal *int32 `json:"principal,omitempty"`
	Priority  int32  `json:"priority"`
	Rule      string `json:"rule"`
}

type ScanExec struct {
	exec *prisma.Exec
}

func (instance *ScanExec) FileHistory(params *FileHistoryParamsExec) *FileHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FileHistoryWhereInput", "FileHistoryOrderByInput", "FileHistory"},
		"fileHistory",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExecArray{ret}
}

func (instance ScanExec) Exec(ctx context.Context) (*Scan, error) {
	var v Scan
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScanExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScanExecArray struct {
	exec *prisma.Exec
}

func (instance ScanExecArray) Exec(ctx context.Context) ([]Scan, error) {
	var v []Scan
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Scan struct {
	ScanId      int32   `json:"scan_id"`
	CompletedAt *string `json:"completedAt,omitempty"`
	StartedAt   string  `json:"startedAt"`
}

type FileHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FileHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FileHistoryConnectionExec) Edges() *FileHistoryEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileHistoryEdge"},
		"edges",
		[]string{"cursor"})

	return &FileHistoryEdgeExec{ret}
}

func (instance *FileHistoryConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFileHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance FileHistoryConnectionExec) Exec(ctx context.Context) (*FileHistoryConnection, error) {
	var v FileHistoryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FileHistoryConnectionExecArray) Exec(ctx context.Context) ([]FileHistoryConnection, error) {
	var v []FileHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileHistoryConnection struct {
}

type FileHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FileHistoryEdgeExec) Node() *FileHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileHistory"},
		"node",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

func (instance FileHistoryEdgeExec) Exec(ctx context.Context) (*FileHistoryEdge, error) {
	var v FileHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FileHistoryEdgeExecArray) Exec(ctx context.Context) ([]FileHistoryEdge, error) {
	var v []FileHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileHistoryEdge struct {
	Cursor string `json:"cursor"`
}

type RuleConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RuleConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RuleConnectionExec) Edges() *RuleEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RuleEdge"},
		"edges",
		[]string{"cursor"})

	return &RuleEdgeExec{ret}
}

func (instance *RuleConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRule"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance RuleConnectionExec) Exec(ctx context.Context) (*RuleConnection, error) {
	var v RuleConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RuleConnectionExecArray) Exec(ctx context.Context) ([]RuleConnection, error) {
	var v []RuleConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleConnection struct {
}

type RuleEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RuleEdgeExec) Node() *RuleExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Rule"},
		"node",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

func (instance RuleEdgeExec) Exec(ctx context.Context) (*RuleEdge, error) {
	var v RuleEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RuleEdgeExecArray) Exec(ctx context.Context) ([]RuleEdge, error) {
	var v []RuleEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleEdge struct {
	Cursor string `json:"cursor"`
}

type RuleResultConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RuleResultConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RuleResultConnectionExec) Edges() *RuleResultEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RuleResultEdge"},
		"edges",
		[]string{"cursor"})

	return &RuleResultEdgeExec{ret}
}

func (instance *RuleResultConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRuleResult"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance RuleResultConnectionExec) Exec(ctx context.Context) (*RuleResultConnection, error) {
	var v RuleResultConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleResultConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleResultConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RuleResultConnectionExecArray) Exec(ctx context.Context) ([]RuleResultConnection, error) {
	var v []RuleResultConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleResultConnection struct {
}

type RuleResultEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RuleResultEdgeExec) Node() *RuleResultExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RuleResult"},
		"node",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

func (instance RuleResultEdgeExec) Exec(ctx context.Context) (*RuleResultEdge, error) {
	var v RuleResultEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleResultEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleResultEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RuleResultEdgeExecArray) Exec(ctx context.Context) ([]RuleResultEdge, error) {
	var v []RuleResultEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleResultEdge struct {
	Cursor string `json:"cursor"`
}

type ScanConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ScanConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ScanConnectionExec) Edges() *ScanEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ScanEdge"},
		"edges",
		[]string{"cursor"})

	return &ScanEdgeExec{ret}
}

func (instance *ScanConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateScan"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ScanConnectionExec) Exec(ctx context.Context) (*ScanConnection, error) {
	var v ScanConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScanConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScanConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ScanConnectionExecArray) Exec(ctx context.Context) ([]ScanConnection, error) {
	var v []ScanConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScanConnection struct {
}

type ScanEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ScanEdgeExec) Node() *ScanExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Scan"},
		"node",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

func (instance ScanEdgeExec) Exec(ctx context.Context) (*ScanEdge, error) {
	var v ScanEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScanEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScanEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ScanEdgeExecArray) Exec(ctx context.Context) ([]ScanEdge, error) {
	var v []ScanEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScanEdge struct {
	Cursor string `json:"cursor"`
}

type DomainUserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *DomainUserSubscriptionPayloadExec) Node() *DomainUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DomainUser"},
		"node",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserExec{ret}
}

func (instance *DomainUserSubscriptionPayloadExec) PreviousValues() *DomainUserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DomainUserPreviousValues"},
		"previousValues",
		[]string{"sid", "groups", "name", "username"})

	return &DomainUserPreviousValuesExec{ret}
}

func (instance DomainUserSubscriptionPayloadExec) Exec(ctx context.Context) (*DomainUserSubscriptionPayload, error) {
	var v DomainUserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainUserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainUserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance DomainUserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]DomainUserSubscriptionPayload, error) {
	var v []DomainUserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DomainUserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type DomainUserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance DomainUserPreviousValuesExec) Exec(ctx context.Context) (*DomainUserPreviousValues, error) {
	var v DomainUserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DomainUserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DomainUserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance DomainUserPreviousValuesExecArray) Exec(ctx context.Context) ([]DomainUserPreviousValues, error) {
	var v []DomainUserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type DomainUserPreviousValues struct {
	Sid      string                 `json:"sid"`
	Groups   map[string]interface{} `json:"groups"`
	Name     string                 `json:"name"`
	Username string                 `json:"username"`
}

type EndpointSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EndpointSubscriptionPayloadExec) Node() *EndpointExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Endpoint"},
		"node",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointExec{ret}
}

func (instance *EndpointSubscriptionPayloadExec) PreviousValues() *EndpointPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EndpointPreviousValues"},
		"previousValues",
		[]string{"endpoint_id", "ignore", "path", "principal"})

	return &EndpointPreviousValuesExec{ret}
}

func (instance EndpointSubscriptionPayloadExec) Exec(ctx context.Context) (*EndpointSubscriptionPayload, error) {
	var v EndpointSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EndpointSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EndpointSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EndpointSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EndpointSubscriptionPayload, error) {
	var v []EndpointSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EndpointSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EndpointPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EndpointPreviousValuesExec) Exec(ctx context.Context) (*EndpointPreviousValues, error) {
	var v EndpointPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EndpointPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EndpointPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EndpointPreviousValuesExecArray) Exec(ctx context.Context) ([]EndpointPreviousValues, error) {
	var v []EndpointPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EndpointPreviousValues struct {
	EndpointId int32  `json:"endpoint_id"`
	Ignore     bool   `json:"ignore"`
	Path       string `json:"path"`
	Principal  *int32 `json:"principal,omitempty"`
}

type FileHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FileHistorySubscriptionPayloadExec) Node() *FileHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileHistory"},
		"node",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryExec{ret}
}

func (instance *FileHistorySubscriptionPayloadExec) PreviousValues() *FileHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileHistoryPreviousValues"},
		"previousValues",
		[]string{"file_history_id", "action", "actionTstamp", "filename"})

	return &FileHistoryPreviousValuesExec{ret}
}

func (instance FileHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*FileHistorySubscriptionPayload, error) {
	var v FileHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FileHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FileHistorySubscriptionPayload, error) {
	var v []FileHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileHistorySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FileHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FileHistoryPreviousValuesExec) Exec(ctx context.Context) (*FileHistoryPreviousValues, error) {
	var v FileHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FileHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]FileHistoryPreviousValues, error) {
	var v []FileHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FileHistoryPreviousValues struct {
	FileHistoryId int32  `json:"file_history_id"`
	Action        string `json:"action"`
	ActionTstamp  string `json:"actionTstamp"`
	Filename      string `json:"filename"`
}

type RuleSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RuleSubscriptionPayloadExec) Node() *RuleExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Rule"},
		"node",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RuleExec{ret}
}

func (instance *RuleSubscriptionPayloadExec) PreviousValues() *RulePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RulePreviousValues"},
		"previousValues",
		[]string{"rule_id", "ignore", "principal", "priority", "rule"})

	return &RulePreviousValuesExec{ret}
}

func (instance RuleSubscriptionPayloadExec) Exec(ctx context.Context) (*RuleSubscriptionPayload, error) {
	var v RuleSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RuleSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RuleSubscriptionPayload, error) {
	var v []RuleSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type RulePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RulePreviousValuesExec) Exec(ctx context.Context) (*RulePreviousValues, error) {
	var v RulePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RulePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RulePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RulePreviousValuesExecArray) Exec(ctx context.Context) ([]RulePreviousValues, error) {
	var v []RulePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RulePreviousValues struct {
	RuleId    int32  `json:"rule_id"`
	Ignore    bool   `json:"ignore"`
	Principal *int32 `json:"principal,omitempty"`
	Priority  int32  `json:"priority"`
	Rule      string `json:"rule"`
}

type RuleResultSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RuleResultSubscriptionPayloadExec) Node() *RuleResultExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RuleResult"},
		"node",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultExec{ret}
}

func (instance *RuleResultSubscriptionPayloadExec) PreviousValues() *RuleResultPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RuleResultPreviousValues"},
		"previousValues",
		[]string{"rule_result_id", "createdAt", "data"})

	return &RuleResultPreviousValuesExec{ret}
}

func (instance RuleResultSubscriptionPayloadExec) Exec(ctx context.Context) (*RuleResultSubscriptionPayload, error) {
	var v RuleResultSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleResultSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleResultSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RuleResultSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RuleResultSubscriptionPayload, error) {
	var v []RuleResultSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleResultSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type RuleResultPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RuleResultPreviousValuesExec) Exec(ctx context.Context) (*RuleResultPreviousValues, error) {
	var v RuleResultPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RuleResultPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RuleResultPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RuleResultPreviousValuesExecArray) Exec(ctx context.Context) ([]RuleResultPreviousValues, error) {
	var v []RuleResultPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RuleResultPreviousValues struct {
	RuleResultId int32                   `json:"rule_result_id"`
	CreatedAt    string                  `json:"createdAt"`
	Data         *map[string]interface{} `json:"data,omitempty"`
}

type ScanSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ScanSubscriptionPayloadExec) Node() *ScanExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Scan"},
		"node",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanExec{ret}
}

func (instance *ScanSubscriptionPayloadExec) PreviousValues() *ScanPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ScanPreviousValues"},
		"previousValues",
		[]string{"scan_id", "completedAt", "startedAt"})

	return &ScanPreviousValuesExec{ret}
}

func (instance ScanSubscriptionPayloadExec) Exec(ctx context.Context) (*ScanSubscriptionPayload, error) {
	var v ScanSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScanSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScanSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ScanSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ScanSubscriptionPayload, error) {
	var v []ScanSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScanSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ScanPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ScanPreviousValuesExec) Exec(ctx context.Context) (*ScanPreviousValues, error) {
	var v ScanPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ScanPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ScanPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ScanPreviousValuesExecArray) Exec(ctx context.Context) ([]ScanPreviousValues, error) {
	var v []ScanPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ScanPreviousValues struct {
	ScanId      int32   `json:"scan_id"`
	CompletedAt *string `json:"completedAt,omitempty"`
	StartedAt   string  `json:"startedAt"`
}
